var antlr4 = require('antlr4/index');

var CalculVisitor = require('antlr-parser/generated-parser/calculVisitor').calculVisitor;
var CalculParser = require('antlr-parser/generated-parser/calculParser').calculParser;

class CompileCalculVisitor extends CalculVisitor {

  logValue(value) {
    let msg = "VALUE: " + value;
    this.outputTarget.value += msg + '\n';
    console.log(msg);
  }

  logVar(varName, value) {
    let msg = "VAR: " + varName + " = " + value;
    this.outputTarget.value += msg + '\n';
    console.log(msg);
  }

  logError(error) {
    let msg = "ERROR! " + error;
    this.outputTarget.value += msg + '\n';
    console.error(msg);
  }

  logAsm(asm) {
    this.asmOut += asm + '\n';
  }
  
  constructor() {
    super();
    this.memory = {
      '@scopeId': 0,
      '@parent': null
    };
    this.currentScope = this.memory;
    this.nextFreeScopeID = 1;
    this.outputTarget = document.getElementById("assembly");
    this.asmOut = ""
    this.stackSize = 0
    this.nextLabelIdx = 0
    this.functionsCounter = 0;
    this.declaredNumbersInScope = 0;
  }

  asmPushVal(val) {
    this.logAsm(`PUSH #${val}`);
    this.stackSize += 1;
    this.declaredNumbersInScope += 1;
  }
  asmPushAddr(addr) {
    this.logAsm(`PUSH [${addr}]`);
    this.stackSize += 1;
  }
  asmPop() {
    this.logAsm(`POP`);
    this.stackSize -= 1;
  }
  asmMovStAddr(stIdx,addr) {
    this.logAsm(`MOV ST(${stIdx}),[${addr}]`);
  }
  asmMovAddrSt(addr,stIdx) {
    this.logAsm(`MOV [${addr}],ST(${stIdx})`);
  }
  asmDup() {
    this.logAsm(`DUP`);
    this.stackSize += 1;
  }
  asmDel() {
    this.logAsm(`DEL`);
    this.stackSize -= 1;
  }
  asmSwap() {
    this.logAsm(`SWAP`);
  }
  asmAdd() {
    this.logAsm(`ADD`);
    this.stackSize -= 1;
  }
  asmSub() {
    this.logAsm(`SUB`);
    this.stackSize -= 1;
  }
  asmMul() {
    this.logAsm(`MUL`);
    this.stackSize -= 1;
  }
  asmDiv() {
    this.logAsm(`DIV`);
    this.stackSize -= 1;
  }
  asmNeg() {
    this.logAsm(`NEG`);
  }
  asmNot() {
    this.logAsm(`NOT`);
  }
  asmCall() {
    this.logAsm(`CALL`);
    this.stackSize += 1;
  }
  asmRet() {
    this.logAsm(`RET`);
    this.stackSize -= 1;
  }
  asmJmp() {
    this.logAsm(`JMP`);
    this.stackSize -= 1;
  }
  asmJe() {
    this.logAsm(`JE`);
    this.stackSize -= 2;
  }
  asmJne() {
    this.logAsm(`JNE`);
    this.stackSize -= 2;
  }
  asmJg() {
    this.logAsm(`JG`);
    this.stackSize -= 2;
  }
  asmJl() {
    this.logAsm(`JL`);
    this.stackSize -= 2;
  }
  asmJge() {
    this.logAsm(`JGE`);
    this.stackSize -= 2;
  }
  asmJle() {
    this.logAsm(`JLE`);
    this.stackSize -= 2;
  }
  asmDd(varName) {
    this.logAsm(`DD ${varName}`);
  }
  asmBrk() {
    this.logAsm(`BRK`);
  }
  asmLabel(label) {
    this.logAsm(`${label}:`);
  }
  asmPrint(varName) {
    this.logAsm(`PRINT ${varName}`);
  }
  asmComment(comment) {
    this.logAsm(`# ${comment}`);
  }

  createLabel(name) {
    let label = `${name}_${this.nextLabelIdx}`
    this.nextLabelIdx += 1;
    return label;
  }

  openNewScope() {
    let scope = this.currentScope;
    let newScope = {
      '@scopeId': this.nextFreeScopeID,
      '@parent': scope
    };
    scope[this.nextFreeScopeID] = newScope;
    this.nextFreeScopeID += 1;
    this.currentScope = newScope;
    return newScope;
  }

  closeScope() {

    if (this.currentScope['@parent'] === null) {
      this.logError("Can't close global scope");
      return this.memory;
    }

    let scopeToRemove = this.currentScope;
    let parentScope = scopeToRemove['@parent'];
    delete parentScope[scopeToRemove['@scopeId']];
    this.currentScope = parentScope;
    return parentScope;
  }

  isDeclared(varName) {
    return this.isDeclaredReq(varName, this.currentScope);
  }

  isDeclaredReq(varName, scope) {
    if (scope !== null) {
      if (scope[varName] !== undefined) {
        return true;
      }
      else {
        return this.isDeclaredReq(varName, scope['@parent']);
      }
    }
    else {
      return false;
    }
  }

  findDeclaration(varName) {
    return this.findDeclarationReq(varName, this.currentScope);
  }

  findDeclarationReq(varName, scope) {
    if (scope !== null) {
      if (scope[varName] !== undefined) {
        return scope[varName];
      }
      else {
        return this.findDeclarationReq(varName, scope['@parent']);
      }
    }
    else {
      return null;
    }
  }

  isDeclaredLocal(varName) {
    return this.currentScope[varName] !== undefined;
  }

  isDeclaredGlobal(varName) {
    return this.memory[varName] !== undefined;
  }

  declareVariable(varName) {
    if (this.isDeclaredLocal(varName)) {
      this.logError("[ " + varName + " ] is already declared in scope.");
      return {"type": 'error'};
    }
    else {
      this.currentScope[varName] = {"type": 'var', "value": 0};
      return this.currentScope[varName];
    }
  }

  defineVariable(varName, value) {
    let vr = this.declareVariable(varName);
    vr.value = Number(value);
    return vr;
  }

  setVariable(varName, value) {

    let vr = this.findDeclaration(varName);

    if (vr === null) {
      this.logError("[ " + varName + " ] is not declarated.");
      return undefined;
    }
    else {
      vr.value = Number(value);
      return vr;
    }
  }

  getVariable(varName) {
    let vr = this.findDeclaration(varName);

    if (vr === null) {
      this.logError("[ " + varName + " ] is not declarated.");
      return undefined;
    }
    else {
      return vr;
    }
  }

  defineFunction(funcName, ctx) {
    if (this.isDeclaredLocal(funcName)) {
      this.logError("[ " + varName + " ] is already in scope.");
      return {"type": 'error'};
    }
    else {
      let asmFuncName = `func_${this.functionsCounter}`;
      this.functionsCounter += 1

      this.currentScope[funcName] = {
        "type": 'func', 
        "ctx": ctx, 
        "name": funcName,
        "asmName": asmFuncName
      };

      return this.currentScope[funcName];
    }
  }

  visitChildren(ctx) {
    if (!ctx) {
      return;
    }

    if (ctx.children) {
      return ctx.children.map(child => {
        if (child.children && child.children.length != 0) {
          return child.accept(this);
        } else {
          return child.getText();
        }
      });
    }
  }

  // Program

  visitProgram(ctx) {
    this.asmLabel("__start")
    this.visitChildren(ctx);

    for (let i = 0; i < this.stackSize; ++i) {
      this.asmDel();
    }

    let asmMem = this.asmOut;
    this.asmOut = "";
    this.asmPushAddr("__start");
    this.asmJmp();
    this.asmOut = this.asmOut + '\n' + asmMem;

    this.outputTarget.value = this.asmOut;

    return null;
  }

  // Stat : DeclVar

  visitDeclVar(ctx) {
    let varName = ctx.VAR_NAME().getText();
    
    this.declareVariable(varName);
    this.asmDd(varName);

    return this.visitChildren(ctx);
  }

  // Stat : DefineVar

  visitDefineVar(ctx) {
    let varName = ctx.VAR_NAME().getText();

    this.declareVariable(varName);
    let stackIdx = this.stackSize;
    this.asmDd(varName);
    this.visit(ctx.expr());
    this.asmMovAddrSt(varName, stackIdx);

    return null;
  }

  // Stat : AssignValue

  visitAssignValue(ctx) {
    let varName = ctx.VAR_NAME().getText();
    
    let stackIdx = this.stackSize;
    this.visit(ctx.expr());
    this.asmMovAddrSt(varName, stackIdx);
    
    return null;
  }

  // Stat : Scope

  visitScope(ctx) {
    let scope = ctx.stat();

    this.openNewScope();   
    let memStackSize = this.stackSize;
    this.stackSize = 0;
    this.visit(scope);
    let elementsToDelele = this.stackSize;
    for (let i = 0; i < elementsToDelele; ++i) {
      this.asmDel();
    }
    this.stackSize = memStackSize;
    this.closeScope();

    return null;
  }

  // Stat : IfInstr

  visitIfInstr(ctx) {
    return this.visitChildren(ctx);
  }

  // Stat : IfElseInstr

  visitIfElseInstr(ctx) {
    return this.visitChildren(ctx);
  }

  // Stat : WhileInstr
  
  visitWhileInstr(ctx) {
    let labelBegin = this.createLabel('while_begin');
    this.nextLabelIdx -= 1;
    let labelEnd = this.createLabel('while_end');

    this.asmLabel(labelBegin);
    this.asmPushAddr(labelEnd);
    this.visit(ctx.expr());
    this.visit(ctx.scope());
    this.asmPushAddr(labelBegin);
    this.asmJmp();
    this.asmLabel(labelEnd);

    return null;
  }

  // Stat : DefineFunc

  visitDefineFunc(ctx) {
    let funcName = ctx.VAR_NAME().getText();
    let scope = ctx.stat();

    let func = this.defineFunction(funcName, null);
    let asmMem = this.asmOut;
    this.asmOut = "";
    this.asmComment(`Define function [${func.name}]`);
    this.asmLabel(func.asmName);


    this.openNewScope();   
    let memStackSize = this.stackSize;
    this.stackSize = 0;
    this.visit(scope);
    let elementsToDelele = this.stackSize;
    for (let i = 0; i < elementsToDelele; ++i) {
      this.asmDel();
    }
    this.stackSize = memStackSize;
    this.closeScope();

    this.asmRet();
    this.asmOut = this.asmOut + '\n' + asmMem;

    return null;
  }

  // Stat : CallFuncOrPrintVar
  
  visitCallFuncOrPrintVar(ctx) {
    let varName = ctx.VAR_NAME().getText();
    let vr = this.getVariable(varName);

    if (vr !== undefined) {
      if (vr.ctx === undefined) {
        this.asmPrint(varName);
      }
      else {
        let func = vr;
        this.asmPushAddr(func.asmName);
        this.asmCall();
      }
    }

    return null;
  }
  
  visitPrintExpr(ctx) {

    let stackIdx = this.stackSize;
    this.visit(ctx.expr());
    this.asmPrint(`ST(${stackIdx})`);

    return null;
  }
  
  // Expr : Minus
  
  visitMinusExpr(ctx) {
    return this.visitChildren(ctx);
  }

  // Expr : Multiply

  visitMultiplyExpr(ctx) {    
    this.visit(ctx.expr(1));
    this.visit(ctx.expr(0));
    let op = ctx.op.type;

    if (op == CalculParser.MULT) {
      this.asmMul();
    }
    else if (op == CalculParser.DIV) {
      this.asmDiv();
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
    }
  }

  // Expr : Add

  visitAddExpr(ctx) {
    this.visit(ctx.expr(1));
    this.visit(ctx.expr(0));
    let op = ctx.op.type;

    if (op == CalculParser.PLUS) {
      this.asmAdd();
    }
    else if (op == CalculParser.MINUS) {
      this.asmSub();
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
    }
  }
  
  // Expr : Compare

  visitCompareExpr(ctx) {    
    this.visit(ctx.expr(1));
    this.visit(ctx.expr(0));
    let op = ctx.op.type;

    if (op == CalculParser.GTEQ) {
      this.asmSub();
      this.asmJge();
    }
    else if (op == CalculParser.LTEQ) {
      this.asmSub();
      this.asmJle();
    }
    else if (op == CalculParser.GT) {
      this.asmSub();
      this.asmJg();
    }
    else if (op == CalculParser.LT) {
      this.asmSub();
      this.asmLt();
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
    }
  }

  // Expr : Equal

  visitEqualExpr(ctx) {
    this.visit(ctx.expr(1));
    this.visit(ctx.expr(0));
    let op = ctx.op.type;

    if (op == CalculParser.EQ) {
      this.asmJe();
    }
    else if (op == CalculParser.NEQ) {
      this.asmJne();
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
    }
  }

  // Expr : IfExpr

  visitIfExpr(ctx) {
    let labelElse = this.createLabel('if_else');
    this.nextLabelIdx -= 1;
    let labelEnd = this.createLabel('if_end');

    this.asmPushAddr(labelElse);
    this.visit(ctx.expr(0));
    this.visit(ctx.expr(1));
    this.asmPushAddr(labelEnd);
    this.asmJmp();
    this.asmLabel(labelElse);
    this.visit(ctx.expr(2));
    this.asmLabel(labelEnd);

    return null;
  }

  // Atom : Number
  
  visitNumberAtom(ctx) {
    let value = ctx.getText();

    this.asmPushVal(value);

    return null;
  }
  
  // Atom : Variable

  visitVarAtom(ctx) {
    let varName = ctx.getText();

    this.asmPushAddr(varName);

    return null;
  }

  // Atom : Brackets

  visitBracketsAtom(ctx) {
    return this.visit(ctx.expr());
  }

}

exports.CompileCalculVisitor = CompileCalculVisitor;