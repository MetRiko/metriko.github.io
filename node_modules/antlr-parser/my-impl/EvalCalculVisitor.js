var antlr4 = require('antlr4/index');

var CalculVisitor = require('antlr-parser/generated-parser/calculVisitor').calculVisitor;
var CalculParser = require('antlr-parser/generated-parser/calculParser').calculParser;

class EvalCalculVisitor extends CalculVisitor {

  logValue(value) {
    let msg = "VALUE: " + value;
    this.outputTarget.value += msg + '\n';
    console.log(msg);
  }

  logVar(varName, value) {
    let msg = "VAR: " + varName + " = " + value;
    this.outputTarget.value += msg + '\n';
    console.log(msg);
  }

  logError(error) {
    let msg = "ERROR! " + error;
    this.outputTarget.value += msg + '\n';
    console.error(msg);
  }

  constructor() {
    super();
    this.memory = {
      '@scopeId': 0,
      '@parent': null
    };
    this.currentScope = this.memory;
    this.nextFreeScopeID = 1;
    this.outputTarget = document.getElementById("output");
  }

  openNewScope() {
    let scope = this.currentScope;
    let newScope = {
      '@scopeId': this.nextFreeScopeID,
      '@parent': scope
    };
    scope[this.nextFreeScopeID] = newScope;
    this.nextFreeScopeID += 1;
    this.currentScope = newScope;
    return newScope;
  }

  closeScope() {

    if (this.currentScope['@parent'] === null) {
      this.logError("Can't close global scope");
      return this.memory;
    }

    let scopeToRemove = this.currentScope;
    let parentScope = scopeToRemove['@parent'];
    delete parentScope[scopeToRemove['@scopeId']];
    this.currentScope = parentScope;
    return parentScope;
  }

  isDeclared(varName) {
    return this.isDeclaredReq(varName, this.currentScope);
  }

  isDeclaredReq(varName, scope) {
    if (scope !== null) {
      if (scope[varName] !== undefined) {
        return true;
      }
      else {
        return this.isDeclaredReq(varName, scope['@parent']);
      }
    }
    else {
      return false;
    }
  }

  findDeclaration(varName) {
    return this.findDeclarationReq(varName, this.currentScope);
  }

  findDeclarationReq(varName, scope) {
    if (scope !== null) {
      if (scope[varName] !== undefined) {
        return scope[varName];
      }
      else {
        return this.findDeclarationReq(varName, scope['@parent']);
      }
    }
    else {
      return null;
    }
  }

  isDeclaredLocal(varName) {
    return this.currentScope[varName] !== undefined;
  }

  isDeclaredGlobal(varName) {
    return this.memory[varName] !== undefined;
  }

  declareVariable(varName) {
    if (this.isDeclaredLocal(varName)) {
      this.logError("[ " + varName + " ] is already declared in scope.");
      return {"type": 'error'};
    }
    else {
      this.currentScope[varName] = {"type": 'var', "value": 0};
      return this.currentScope[varName];
    }
  }

  defineVariable(varName, value) {
    let vr = this.declareVariable(varName);
    vr.value = Number(value);
    return vr;
  }

  setVariable(varName, value) {

    let vr = this.findDeclaration(varName);

    if (vr === null) {
      this.logError("[ " + varName + " ] is not declarated.");
      return undefined;
    }
    else {
      vr.value = Number(value);
      return vr;
    }
  }

  getVariable(varName) {
    let vr = this.findDeclaration(varName);

    if (vr === null) {
      this.logError("[ " + varName + " ] is not declarated.");
      return undefined;
    }
    else {
      return vr;
    }
  }

  defineFunction(funcName, ctx) {
    if (this.isDeclaredLocal(funcName)) {
      this.logError("[ " + varName + " ] is already in scope.");
      return {"type": 'error'};
    }
    else {
      this.currentScope[funcName] = {"type": 'func', "ctx": ctx};
      return this.currentScope[funcName];
    }
  }

  callFunction(funcName) {
    let func = this.findDeclaration(funcName);

    if (func === null) {
      this.logError("[ " + funcName + " ] is not declarated.");
    }
    else {
      if (func.ctx !== undefined) {
        this.openNewScope();     
        this.visit(func.ctx);        
        this.closeScope();
      }
      else {
        this.logError("[ " + funcName + " ] is not a function.");
      }
    }
  }

  visitChildren(ctx) {
    if (!ctx) {
      return;
    }

    if (ctx.children) {
      return ctx.children.map(child => {
        if (child.children && child.children.length != 0) {
          return child.accept(this);
        } else {
          return child.getText();
        }
      });
    }
  }

  // Stat : DeclVar

  visitDeclVar(ctx) {
    let varName = ctx.VAR_NAME().getText();

    let vr = this.declareVariable(varName);
    return vr;
  }

  // Stat : DefineVar

  visitDefineVar(ctx) {
    let varName = ctx.VAR_NAME().getText();
    let value = this.visit(ctx.expr());

    let vr = this.defineVariable(varName, value);
    return vr;
  }

  // Stat : AssignValue

  visitAssignValue(ctx) {
    let varName = ctx.VAR_NAME().getText();
    let value = this.visit(ctx.expr());

    let vr = this.setVariable(varName, value);
    return vr;
  }

  // Stat : Scope

  visitScope(ctx) {
    this.openNewScope();
    this.visit(ctx.stat());
    this.closeScope();
    return this.currentScope;
  }

  // Stat : IfInstr

  visitIfInstr(ctx) {
    let cond = this.visit(ctx.expr()).value;
    if (cond !== 0) {
      return this.visit(ctx.scope());
    }
    return this.currentScope;
  }

  // Stat : IfElseInstr

  visitIfElseInstr(ctx) {
    let cond = Number(this.visit(ctx.expr()));    
    
    if (cond !== 0) {
      return this.visit(ctx.scope(0));
    }
    else {
      return this.visit(ctx.scope(1));
    }
  }

  // Stat : WhileInstr
  
  visitWhileInstr(ctx) {
    let cond = Number(this.visit(ctx.expr()));
    
    let MAX_COUNT = 20;
    while (cond !== 0) {      
      this.visit(ctx.scope(0));
      cond = Number(this.visit(ctx.expr()));

      --MAX_COUNT;
      if (MAX_COUNT <= 0) break;
    }
    
    return this.memory.currentScope;
  }

  // Stat : DefineFunc

  visitDefineFunc(ctx) {
    let funcName = ctx.VAR_NAME().getText();
    let scope = ctx.stat();

    this.defineFunction(funcName, scope);
  }

  // Stat : CallFuncOrPrintVar
  
  visitCallFuncOrPrintVar(ctx) {
    let varName = ctx.VAR_NAME().getText();
    let vr = this.getVariable(varName);

    if (vr !== undefined) {

      if (vr.ctx === undefined) {
        this.logVar(varName, vr.value);
      }
      else {
        this.callFunction(varName, vr.ctx);
      }
    }
    return null;
  }
  
  visitPrintExpr(ctx) {
    let value = Number(this.visit(ctx.expr()));

    this.logValue(value);
    return value;
  }
  
  // Expr : Minus
  
  visitMinusExpr(ctx) {
    let value = this.visit(ctx.expr());
    return -Number(value);
  }

  // Expr : Multiply

  visitMultiplyExpr(ctx) {
    let left = this.visit(ctx.expr(0));
    let right = this.visit(ctx.expr(1));
    let op = ctx.op.type;

    if (op == CalculParser.MULT) {
      return Number(left) * Number(right);
    }
    else if (op == CalculParser.DIV) {
      return Number(left) / Number(right);
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
      return 0;
    }    
  }

  // Expr : Add

  visitAddExpr(ctx) {
    let left = this.visit(ctx.expr(0));
    let right = this.visit(ctx.expr(1));
    let op = ctx.op.type;

    if (op == CalculParser.PLUS) {
      return Number(left) + Number(right);
    }
    else if (op == CalculParser.MINUS) {
      return Number(left) - Number(right);
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
      return 0;
    }
  }
  
  // Expr : Compare

  visitCompareExpr(ctx) {
    let left = this.visit(ctx.expr(0));
    let right = this.visit(ctx.expr(1));
    let op = ctx.op.type;

    if (op == CalculParser.LTEQ) {
      return Number(left) <= Number(right) ? 1 : 0;
    }
    else if (op == CalculParser.GTEQ) {
      return Number(left) >= Number(right) ? 1 : 0;
    }
    else if (op == CalculParser.LT) {
      return Number(left) < Number(right) ? 1 : 0;
    }
    else if (op == CalculParser.GT) {
      return Number(left) > Number(right) ? 1 : 0;
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
      return 0;
    }
  }

  // Expr : Equal

  visitEqualExpr(ctx) {
    let left = this.visit(ctx.expr(0));
    let right = this.visit(ctx.expr(1));
    let op = ctx.op.type;

    if (op == CalculParser.EQ) {
      return Number(left) === Number(right) ? 1 : 0;
    }
    else if (op == CalculParser.NEQ) {
      return Number(left) !== Number(right) ? 1 : 0;
    }
    else {
      this.logError("Unexpected operator: " + op.getText());
      return 0;
    }
  }

  // Expr : IfExpr

  visitIfExpr(ctx) {
    let cond = this.visit(ctx.expr(0));
    let trueValue = this.visit(ctx.expr(1));
    let falseValue = this.visit(ctx.expr(2));

    return cond ? trueValue : falseValue;
  }

  // Atom : Number
  
  visitNumberAtom(ctx) {
    let value = parseFloat(ctx.getText());
    return value;
  }
  
  // Atom : Variable

  visitVarAtom(ctx) {
    let varName = ctx.getText();

    let vr = this.getVariable(varName);

    if(vr === undefined) {
      return 0;
    }
    
    return Number(vr.value);
  }

  // Atom : Brackets

  visitBracketsAtom(ctx) {
    let value = this.visit(ctx.expr());
    return value;
  }

}

exports.EvalCalculVisitor = EvalCalculVisitor;