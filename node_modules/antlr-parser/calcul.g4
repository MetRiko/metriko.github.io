grammar calcul;

/* PARSER */

program:
    source? EOF;

source:
    stat+;

stat:
    declVar
    | defineVar
    | assignValue
    | scope
    | ifInstr
    | ifElseInstr
    | whileInstr
    | defineFunc
    | callFuncOrPrintVar
    | printExpr
    | EOS;

declVar:
    VAR VAR_NAME EOS;

defineVar:
    VAR VAR_NAME ASSIGN expr EOS;

assignValue:
    VAR_NAME ASSIGN expr EOS;

ifInstr: 
    IF expr scope; 

ifElseInstr: 
    IF expr scope ELSE scope;

whileInstr:
    WHILE expr scope;

defineFunc:
    FUNC VAR_NAME L_SCOPE_BRACKET stat* R_SCOPE_BRACKET EOS;

callFuncOrPrintVar:
    VAR_NAME EOS;

printExpr:
    expr EOS;

scope:
    L_SCOPE_BRACKET stat* R_SCOPE_BRACKET EOS;

expr:
    MINUS expr                                  #minusExpr
    | expr op=(MULT | DIV) expr                 #multiplyExpr
    | expr op=(PLUS | MINUS) expr               #addExpr
    | expr op=(LTEQ | GTEQ | LT | GT) expr      #compareExpr
    | expr op=(EQ | NEQ) expr                   #equalExpr
    | IF expr THEN expr ELSE expr               #ifExpr
    | atom                                      #atomExpr
    ;

atom: 
    (INT | REAL)                            #numberAtom
    | VAR_NAME                              #varAtom
    | L_ROUND_BRACKET expr R_ROUND_BRACKET  #bracketsAtom
    ;

/* LEXER */

EOS : [\n];
WS : [ \t\r\n] -> skip;

IF : 'if';
THEN : 'then';
ELSE : 'else';

WHILE : 'while';

FUNC : 'func';

PLUS : '+';
MINUS : '-';
MULT : '*';
DIV : '/';

LTEQ : '<=';
GTEQ : '>=';
LT : '<';
GT : '>';
EQ : '==';
NEQ : '!=';
AND : 'and';
OR : 'or';
NOT : '!';

ASSIGN : '=';

L_SCOPE_BRACKET : '{';
R_SCOPE_BRACKET : '}';

L_ROUND_BRACKET : '(';
R_ROUND_BRACKET : ')';

PRINT : 'print';

VAR : 'var';

VAR_NAME : [a-zA-Z_] [a-zA-Z_0-9]*;
FUNC_NAME : [a-zA-Z_] [a-zA-Z_0-9]*;

INT : [0-9]+;

REAL : [0-9]+ '.' [0-9]* | '.' [0-9]+;

COMMENT : '//' ~[\r\n]* -> skip;
